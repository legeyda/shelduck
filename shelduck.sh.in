
# see https://github.com/ajdiaz/bashdoc


# fun: shelduck CLIARGS...
shelduck() {
	shelduck_eval "$@"
}



shelduck_usage() {
	printf %s 'Usage: shelduck URL [ALIAS...]'
}



# fun: shelduck_eval CLIARGS...
shelduck_eval() {
	shelduck_eval_script="$(shelduck_print "$@" || bobshell_die 'shelduck_eval: error calling shelduck_print')"
	eval "$shelduck_eval_script"
	unset shelduck_eval_script
}



# fun: shelduck_print CLIARGS...
shelduck_print() {
	# set starting parameters
	shelduck_url_history=
	shelduck_alias_strategy="${SHELDUCK_ALIAS_STRATEGY:-wrap}"
	
	# delegate
	shelduck_print_internal "${SHELDUCK_BASE_URL:-}" "$@"
}



# fun: shelduck_print_internal BASEURL CLIARGS...
# env: shelduck_url_history
#      shelduck_alias_strategy
# txt: parse cli and delegate to shelduck_print_tree
shelduck_print_internal() {
	# parse cli, save to local array: ABSURL [ALIAS...]
	# todo normal cli
	shelduck_print_internal_absurl=$(bobshell_resolve_url "$2" "$1")
	shift 2
	set -- "$shelduck_print_internal_absurl" "$@"
	unset shelduck_print_internal_absurl

	shelduck_print_internal_script=$(shelduck_print_origin "$@" || bobshell_die 'shelduck_print_internal: shelduck_print_origin failed') || bobshell_die debug
	set -- "$shelduck_print_internal_script" "$@"
	unset shelduck_print_internal_script

	if ! bobshell_contains "$shelduck_url_history" "$2"; then
		shelduck_compile "$@"
		shelduck_url_history="$shelduck_url_history $2"
	fi

	
	shelduck_print_addition "$@"
}

# fun: shelduck_call_shifted SHIFTNUMBER DELEGATE [ARG...]
shelduck_call_shifted() {
	shelduck_call_shifted_shiftnumber="$1"
	shelduck_call_shifted_delegate="$2"
	shift 2
	shift "$shelduck_call_shifted_shiftnumber"
	"$shelduck_call_shifted_delegate" "$@"
}



# fun: shelduck_compile SCRIPT ABSURL [ALIAS...]
# txt: print recusively expanded shelduck commands, and print rewritten rest of script
shelduck_compile() {
	shelduck_compile_input="$1"
	shift
	
	printf %s "# shelduck: source for $1"

	shelduck_compile_before=
	shelduck_compile_after=
	while bobshell_split2 "$shelduck_compile_input" "${bobshell_newline}shelduck " shelduck_compile_before shelduck_compile_after; do
		# print everything before the first found shelduck command
		shelduck_rewrite "$shelduck_compile_before$bobshell_newline" "$@"
		
		
		shelduck_compile_input="$shelduck_compile_after"

		shelduck_compile_command=
		while true; do
			if ! bobshell_split2 "$shelduck_compile_input" "${bobshell_newline}" shelduck_compile_before shelduck_compile_after; then
				shelduck_compile_command="$shelduck_compile_input"
				shelduck_compile_input=
				break
			fi

			if ! bobshell_ends_with "$shelduck_compile_before" '\' shelduck_compile_before; then
				shelduck_compile_command="$shelduck_compile_command$shelduck_compile_before"
				shelduck_compile_input="$bobshell_newline$shelduck_compile_after"
				break;
			fi
			
			# todo strip trailing backslash
			shelduck_compile_command="$shelduck_compile_command${shelduck_compile_before}"
			shelduck_compile_input="$shelduck_compile_after"

		done
		
		# assert shelduck argument command line not empty
		if [ -z "$shelduck_compile_command" ]; then
			bobshell_die 'empty shelduck arguments'
		fi

		# get base url to pass ot depenencies
		shelduck_compile_base_url=
		if [ -n "$1" ]; then
			shelduck_compile_base_url=$(bobshell_base_url "$1")
		fi

		# before recursive call, save variables to local array
		set -- "$shelduck_compile_input" "$@"

		# recursive call, concously not double qouting
		# shellcheck disable=SC2086
		shelduck_print_internal "$shelduck_compile_base_url" $shelduck_compile_command

		# after recursive call, restore variables from local array
		shelduck_compile_input="$1"
		shift
	done
				

	# print everything after last found shelduck command
	shelduck_rewrite "$shelduck_compile_input" "$@"
}





# fun: shelduck_print_origin ABSURL [ALIAS...]
# txt: prints original script without modification
shelduck_print_origin() {
	shelduck_cached_fetch_url "$1"
}




# fun: shelduck_reprint_script ORIGCONTENT ABSURL [ALIAS...]
# txt: rewrite original script (e.g. rename function)
shelduck_rewrite() {
	if [ rename = "${shelduck_alias_strategy:-}" ]; then
		bobshell_die "shelduck_alias_strategy: value $shelduck_alias_strategy not supported"
	fi
	# comment out shelduck dependency directive
	printf %s "$1"
}




# fun: shelduck_print_addition ORIGCONTENT ABSURL [ALIAS...]
# txt: print script additional code (e.g. aliases) 
shelduck_print_addition() {

	if [ wrap != "$shelduck_alias_strategy" ]; then
		# nothing to do, wrap was the only supported customization
		return
	fi

	# analyze functions (for aliases)
	regex='^ *([A-Za-z0-9_]+) *\( *\) *\{ *$' # match shell function declaration '  function_name  (   )  {  '
	shelduck_print_addition_function_names="$(printf %s "$1" | sed --silent --regexp-extended "s/$regex/\1/p")"
	unset regex
	# todo detect function name collizion and print warning if so
	

	# analyze aliases
	shelduck_print_addition_url="$2"
	shift 2
	for arg in "$@"; do
		# todo assert $arg not empty
		if ! bobshell_split2 "$arg" = key value; then
			key="$arg"
			value="$arg"
		fi
		bobshell_require_not_empty "$key"   line "$arg": key   expected not to be empty
		bobshell_require_not_empty "$value" line "$arg": value expected not to be empty
		
		shelduck_print_script_function_name="$(printf %s "$shelduck_print_addition_function_names" | grep -E "^.*$value\$" || true)"
		if [ -n "$shelduck_print_script_function_name" ]; then
			if [ wrap = "$shelduck_alias_strategy" ]; then
				printf '\n\n'
				printf '\n # shelduck: alias for %s (from %s)' "$shelduck_print_script_function_name" "$shelduck_print_addition_url" 
				printf '\n%s() {' "$key"
				printf '\n	%s "$@"' "$shelduck_print_script_function_name"
				printf '\n}'
				printf '\n'
			fi
		fi
		unset key value shelduck_print_script_function_name
	done
	unset shelduck_print_addition_function_names shelduck_print_addition_url
}




# fun: shelduck_cached_fetch_url ABSURL
# txt: download dependency given url and save to cache
shelduck_cached_fetch_url() {
	# bypass cache if local file
	if bobshell_starts_with "$1" 'file://' file_name; then
		# shellcheck disable=SC2154
		# starts_with sets variable file_name indirectly
		if ! [ -f "$file_name" ]; then
			bobshell_die "shelduck: dependency fetch error '$1': file '$file_name' not found"
		fi
		cat "$file_name" || bobshell_die "shelduck: dependency fetch error '$1': error loading '$file_name'"
		unset file_name
		return
	fi
	# todo implement cache
	# todo timeout
	bobshell_fetch_url "$1" || bobshell_die "shelduck: dependency fetch error '$1': error downloading '$1'"
}

