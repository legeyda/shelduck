
# see https://github.com/ajdiaz/bashdoc



shelduck() {
	shelduck_eval "$@"
}


shelduck_usage() {
	printf %s 'Usage: shelduck URL [ALIAS...]'
}

shelduck_eval() {
	shelduck_eval_script="$(shelduck_print "$@")"
	eval "$shelduck_eval_script"
	unset shelduck_eval_script
}

shelduck_print() {
	shelduck_url_base=
	shelduck_url_history=
	shelduck_alias_strategy=wrap

	shelduck_print_internal "$@"
}


# shelduck_parse_cli() {
# 	shelduck_parse_cli_url="$1"
# 	shift
# 	shelduck_parse_cli_aliases="$*"
# }


# env: shelduck_print_url_history
shelduck_print_internal() {
	# todo normal cli
	abs_url=$(bobshell_resolve_url "$1" "${SHELDUCK_BASE_URL:-}")
	shift
	set -- "$abs_url" "$@"
	unset abs_url

	if ! bobshell_contains "$shelduck_url_history" "$1"; then
		shelduck_print_tree "$@"
	else
		shelduck_print_script "$@"
	fi

	shelduck_url_history="$shelduck_url_history $1"
}


# fun: shelduck_print_script URL [ALIAS...]
# txt: print script and all dependencies recursively
shelduck_print_tree() {
	#: "${shelduck_url_base:=${SHELDUCK_BASE_URL:-}}"


	# # mark recursive function enter
	# : "${shelduck_print_script_depth:=0}"
	# if [ 0 -eq "$shelduck_print_script_depth" ]; then
	# 	shelduck_print_tree_urls=
	# 	shelduck_alias_strategy=wrap
	# 	shelduck_url_base="${SHELDUCK_BASE_URL:-}"
	# else
	# 	shelduck_alias_strategy=rename
	# 	shelduck_url_base="$shelduck_print_tree_url"
	# fi
	# shelduck_print_script_depth=$(( 1 + shelduck_print_script_depth ))





	# resolve abs url
	shelduck_print_tree_url=$(bobshell_resolve_url "$1" "$shelduck_url_base")
	shift
	set -- "$shelduck_print_tree_url" "$@"
	unset shelduck_print_tree_url

	# url base
	shelduck_print_tree_url_base=$(bobshell_base_url "$1")

	# load script
	shelduck_print_tree_current_script=$(shelduck_print_script "$@")
	
	# save to local array
	set -- "$1" "$shelduck_print_tree_url_base" "$shelduck_print_tree_current_script"
	
	# print dependencies
	shelduck_print_dependencies "$shelduck_print_tree_current_script"
	

	# print script to result
	printf '\n\n\n\n'
	printf '# shelduck dependency: %s\n\n' "$3"
	printf %s "$3"



	# # mark recursive function exit
	# shelduck_print_script_depth=$(( -1 + shelduck_print_script_depth ))
	# if [ 0 -eq "$shelduck_print_script_depth" ]; then
	# 	unset shelduck_print_script_depth shelduck_print_script_previous_url shelduck_print_tree_urls shelduck_url_base
	# fi
}


# fun: shelduck_for_each_line SCRIPT
# txt: supports recursion
shelduck_print_dependencies() {
	# grep for shelduck commands and save to $1
	shelduck_print_tree_dep_lines=$(printf %s "$1" | sed --silent --regexp-extended 's/^ *shelduck (.*)$/\1/pg')
	set -- "$shelduck_print_tree_dep_lines"
	unset shelduck_print_tree_dep_lines

	shelduck_print_dependencies_part=
	bobshell_for_each_part "$1" '
' shelduck_print_dependencies_part eval shelduck_print_internal '$shelduck_print_dependencies_part'
	unset shelduck_print_dependencies_part
}



# fun: shelduck_print_script ABSURL [ALIAS...]
# txt: prints script with its aliases
shelduck_print_script() {

	# print script
	shelduck_print_script_output=$(shelduck_cached_fetch_url "$1")
	if ! bobshell_contains "$shelduck_url_history" "$1"; then
		# todo remove duplicate check
		printf %s "$shelduck_print_script_output"
	fi


	# analyze functions (for aliases)
	regex='^ *([A-Za-z0-9_]+) *\( *\) *\{ *$' # match shell function declaration '  function_name  (   )  {  '
	shelduck_print_script_function_names="$(printf %s "$shelduck_print_script_output" | sed --silent --regexp-extended "s/$regex/\1/p")"
	unset regex shelduck_print_script_output
	# todo detect function name collizion and print warning if so
	

	# analyze aliases
	shift
	for arg in "$@"; do
		# todo assert $arg not empty
		if ! bobshell_split_key_value "$arg" = key value; then
			key="$arg"
			value="$arg"
		fi
		bobshell_require_not_empty "$key"   line "$arg": key   expected not to be empty
		bobshell_require_not_empty "$value" line "$arg": value expected not to be empty
		
		shelduck_print_script_function_name="$(printf %s "$shelduck_print_script_function_names" | grep -E "^.*$value\$")"
		if [ -n "$shelduck_print_script_function_name" ]; then
			if [ wrap = "$shelduck_alias_strategy" ]; then
				printf '\n\n%s(){\n	%s "$@"\n}\n' "$key" "$shelduck_print_script_function_name"
			else
				bobshell_die "shelduck_alias_strategy: value $shelduck_alias_strategy not supported"
			fi
		fi
		unset key value shelduck_print_script_function_name
	done
	unset shelduck_print_script_function_names	
}




shelduck_cached_fetch_url() {
	# bypass cache if local file
	if bobshell_starts_with "$1" 'file://' file_name; then
		# shellcheck disable=SC2154
		# starts_with sets variable file_name indirectly
		cat "$file_name"
		unset file_name
		return
	fi
	# todo implement cache
	# todo timeout
	bobshell_fetch_url "$1"
}

